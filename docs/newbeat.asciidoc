= Developer guide: creating a new Beat

This guide walks you through the steps for creating a new Elastic Beat.
The Beats are a collection of lightweight daemons that collection
operational data from your servers and ship it to Logstash or Elasticsearch.
The common parts from all Beats are placed in the libbeat library, which
contains packages for sending data to Elasticsearch and Logstash, for
configuration file handling, for signal handling, for logging and so on. By
using this common framework, we can ensure that all Beats are behaving the same
and they are easy to package and run with common tools.

== Getting ready

Libbeat and all Beats are written in http://golang.org/[Go], so having it
installed and knowing its basics is a prerequisite for understanding this guide.
However, don't worry if you are not yet a Go expert, it is a sufficiently new
language that very few people can consider themselves experts.  In fact, several
people learned Go by contributing to Packetbeat & libbeat, including the
original Packetbeat authors.

To exemplify this guide with a working example, we will follow
https://github.com/elastic/topbeat[Topbeat] source code. Topbeat is similar to
the `top` command line tool but instead of printing the statistics to the screen
it ships them to Elasticsearch for storage.

After having https://golang.org/doc/install[installed Go] and having setup the
https://golang.org/doc/code.html#GOPATH[GOPATH] environment variable to point to
your preferred workspace location, a simple way of getting the source code for
topbeat and libeat and compiling them at the same time is to do:

[source,shell]
----------------------------------------------------------------------
go get github.com/elastic/topbeat
----------------------------------------------------------------------

== Overview

At the high level, a simple Beat like Topbeat has two main components: one that
collects the actual data and the Publisher. They communicate via a Go channel,
over which *events* are sent. The Publisher is implemented in libbeat, so you
typically only have to worry about the logic specific to your Beat. Besides the
Publisher, libbeat offers common services like configuration management,
logging, daemonizing/windows service handling and in the future it will offer
data processing modules like filtering or sampling.

image:./images/beat_overview.png[Beat overview architecture]

An event is JSON like object (Golang type `map[string]interface{}`) that
contains the collected data and which is indexed into Elasticsearch. The only
rules are that it must contain a `timestamp` field and a `type` field. Beyond
that, it doesn't matter what these events contain or how often they are created.
Here is an example Topbeat event:

[source,json]
----------------------------------------------------------------------
{
  count":1,
  "proc.cpu":{
    "user":20,
    "percent":0.983284169124877,
    "system":0,
    "total":20,
    "start_time":"20:20"
  },
  "proc.mem":{
    "size":333772,
    "rss":6316,
    "share":2996
  },
  "proc.name":"topbeat",
  "proc.pid":13954,
  "proc.ppid":10027,
  "proc.state":"sleeping",
  "shipper":"vagrant-ubuntu-trusty-64",
  "timestamp":"2015-08-06T20:20:34.089Z",
  "type":"proc"
}
----------------------------------------------------------------------

Now that you have the big picture, lets dig into the code.

== Beat specific code

For Topbeat, the Beat specific logic is contained in a type called Topbeat.
There's more code in it, but here are the relevant portions for this guide:


[source,go]
----------------------------------------------------------------------
type Topbeat struct {
    isAlive  bool
    [ ... other fields ...]

    events chan common.MapStr <1>
}

func (t *Topbeat) Run() error {
    t.isAlive = true
    t.initProcStats()

    for t.isAlive { <2>
        time.Sleep(t.period)
        t.exportSystemStats()
        t.exportProcStats()
    }
    return nil
}

func (t *Topbeat) Stop() {
    t.isAlive = false
}
----------------------------------------------------------------------

<1> The events channel is the channel through which the events are sent to the
publisher. The `common.MapStr` type is essentially a `map[string][interface{}`
with a few more convenience
https://github.com/elastic/libbeat/blob/fae9cf861b58f09cf578245e45415899f4151d32/common/mapstr.go[methods] added.

<2> The main loop

The type has two methods, the `Run` method, which contains the main
loop of the application and the `Stop` method which simply provides a way of
breaking the loop.

Inside the loop, Topbeat sleeps for a configured period of time and then
captures the required data and sends it to the publisher via the `events`
channel.

The actual sending is done inside the `exportSystemStats()` and
`exportProcStats()` functions, here is an example code snippet:

[source,go]
----------------------------------------------------------------------
  event := common.MapStr{
      "timestamp": common.Time(time.Now()), <1>
      "type":      "system",
      "load":      load_stat,
      "cpu":       cpu_stat,
      "mem":       mem_stat,
      "swap":      swap_stat,
  }

  t.events <- event
----------------------------------------------------------------------

<1> The `timestamp` fields needs to be of time `common.Time`.

== The main function

If you follow the Topbeat model and put your Beat specific code in it's own type
that implements the `Run` and `Stop` methods, the `main` routing becomes a bit
of copy-pastable boiler plate:

[source,go]
----------------------------------------------------------------------
func main() {

    // Use our own FlagSet, because some libraries pollute the global one
    var cmdLine = flag.NewFlagSet(os.Args[0], flag.ExitOnError)

    cfgfile.CmdLineFlags(cmdLine, Name) <1>
    logp.CmdLineFlags(cmdLine)
    service.CmdLineFlags(cmdLine)
    publisher.CmdLineFlags(cmdLine)

    printVersion := cmdLine.Bool("version", false, "Print version and exit") <2>

    cmdLine.Parse(os.Args[1:])

    if *printVersion {
        fmt.Printf("%s version %s (%s)\n", Name, Version, runtime.GOARCH)
        return
    }

    err := cfgfile.Read(&Config) <3>

    logp.Init(Name, &Config.Logging)

    logp.Debug("main", "Initializing output plugins")
    if err = publisher.Publisher.Init(Config.Output, Config.Shipper); err != nil
    { <4>
        logp.Critical(err.Error())
        os.Exit(1)
    }

    topbeat := &Topbeat{}
    if err = topbeat.Init(Config.Input, publisher.Publisher.Queue); err != nil {
    <5>
        logp.Critical(err.Error())
        os.Exit(1)
    }

    // Up to here was the initialization
    if cfgfile.IsTestConfig() { <6>
        // all good, exit with 0
        os.Exit(0)
    }
    service.BeforeRun()

    service.HandleSignals(topbeat.Stop) <7>

    // Startup successful, disable stderr logging if requested by
    // cmdline flag
    logp.SetStderr()

    logp.Debug("main", "Starting topbeat")

    err = topbeat.Run() <8>
    if err != nil {
        logp.Critical("Sniffer main loop failed: %v", err)
        os.Exit(1)
    }

    logp.Debug("main", "Cleanup")
    service.Cleanup()
}
----------------------------------------------------------------------

<1> libbeat modules can provide their own command line flags. `Name` is a
global constant and it represents the name of the Beat.

<2> The Beat can also define its own custom CLI flags. In this case,
`-version` is the only custom flag.

<3> Read the configuration file, see the next section for details.

<4> Publisher initialization, receiving the relevant configuration sections.

<5> The Topbeat module initialization, receiving the relevant configuration
section and the channel to the Publisher as paramters.

<6> The Beats have a test config mode, this is handled here.

<7> Unix signals and Windows control service commands are handled here.

<8> Run the main loop.


== Configuration

The recommended way of handling the configuration is to create a
`ConfigSettings` type that contains the options that are custom to your Beat but
also the configuration sections that are the same for all Beats and defined in
libbeat.

Here is the entire configuration handling in Topbeat:

[source,go]
----------------------------------------------------------------------
package main

import (
    "github.com/elastic/libbeat/logp"
    "github.com/elastic/libbeat/outputs"
    "github.com/elastic/libbeat/publisher"
)

type ConfigSettings struct {
    Input   TopConfig <1>
    Output  map[string]outputs.MothershipConfig <2>
    Logging logp.Logging
    Shipper publisher.ShipperConfig
}

type TopConfig struct {
    Period *int64 <3>
    Procs  *[]string
}

var Config ConfigSettings <4>
----------------------------------------------------------------------

<1> The configuration options that are specific to Topbeat are grouped in the
`TopConfig` structure.

<2> The configuration settings for the output plugins, logging and the shipper
are defined in libbeat and only included here.

<3> If you need to separate between the default zero value and the option not
being present at all in the configuration, use a pointer. If it's nil, the
option was not present at all.

<4> `Config` is a global variable containing all configuration options.
